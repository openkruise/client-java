/*
* Kruise
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.openkruise.client.models;

import com.google.gson.annotations.SerializedName;
import io.kubernetes.client.custom.IntOrString;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import javax.annotation.Generated;

/**
 * UpdateStrategy indicates the UpdateStrategy that will be employed to update Pods in the CloneSet when a revision is made to Template.
 */
@ApiModel(description = "UpdateStrategy indicates the UpdateStrategy that will be employed to update Pods in the CloneSet when a revision is made to Template.")
@Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2023-07-21T15:55:09.049+08:00")
public class KruiseAppsV1alpha1CloneSetUpdateStrategy {
  @SerializedName("inPlaceUpdateStrategy")
  private KruiseAppsPubInPlaceUpdateStrategy inPlaceUpdateStrategy = null;

  @SerializedName("maxSurge")
  private IntOrString maxSurge = null;

  @SerializedName("maxUnavailable")
  private IntOrString maxUnavailable = null;

  @SerializedName("partition")
  private IntOrString partition = null;

  @SerializedName("paused")
  private Boolean paused = null;

  @SerializedName("priorityStrategy")
  private KruiseAppsPubUpdatePriorityStrategy priorityStrategy = null;

  @SerializedName("scatterStrategy")
  private List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy = null;

  @SerializedName("type")
  private String type = null;

  public KruiseAppsV1alpha1CloneSetUpdateStrategy inPlaceUpdateStrategy(KruiseAppsPubInPlaceUpdateStrategy inPlaceUpdateStrategy) {
    this.inPlaceUpdateStrategy = inPlaceUpdateStrategy;
    return this;
  }

   /**
   * Get inPlaceUpdateStrategy
   * @return inPlaceUpdateStrategy
  **/
  @ApiModelProperty(value = "")
  public KruiseAppsPubInPlaceUpdateStrategy getInPlaceUpdateStrategy() {
    return inPlaceUpdateStrategy;
  }

  public void setInPlaceUpdateStrategy(KruiseAppsPubInPlaceUpdateStrategy inPlaceUpdateStrategy) {
    this.inPlaceUpdateStrategy = inPlaceUpdateStrategy;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy maxSurge(IntOrString maxSurge) {
    this.maxSurge = maxSurge;
    return this;
  }

   /**
   * The maximum number of pods that can be scheduled above the desired replicas during update or specified delete. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.
   * @return maxSurge
  **/
  @ApiModelProperty(value = "The maximum number of pods that can be scheduled above the desired replicas during update or specified delete. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up. Defaults to 0.")
  public IntOrString getMaxSurge() {
    return maxSurge;
  }

  public void setMaxSurge(IntOrString maxSurge) {
    this.maxSurge = maxSurge;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy maxUnavailable(IntOrString maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
    return this;
  }

   /**
   * The maximum number of pods that can be unavailable during update or scale. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge &gt; 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.
   * @return maxUnavailable
  **/
  @ApiModelProperty(value = "The maximum number of pods that can be unavailable during update or scale. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. When maxSurge > 0, absolute number is calculated from percentage by rounding down. Defaults to 20%.")
  public IntOrString getMaxUnavailable() {
    return maxUnavailable;
  }

  public void setMaxUnavailable(IntOrString maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy partition(IntOrString partition) {
    this.partition = partition;
    return this;
  }

   /**
   * Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.
   * @return partition
  **/
  @ApiModelProperty(value = "Partition is the desired number of pods in old revisions. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding up by default. It means when partition is set during pods updating, (replicas - partition value) number of pods will be updated. Default value is 0.")
  public IntOrString getPartition() {
    return partition;
  }

  public void setPartition(IntOrString partition) {
    this.partition = partition;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy paused(Boolean paused) {
    this.paused = paused;
    return this;
  }

   /**
   * Paused indicates that the CloneSet is paused. Default value is false
   * @return paused
  **/
  @ApiModelProperty(value = "Paused indicates that the CloneSet is paused. Default value is false")
  public Boolean isPaused() {
    return paused;
  }

  public void setPaused(Boolean paused) {
    this.paused = paused;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy priorityStrategy(KruiseAppsPubUpdatePriorityStrategy priorityStrategy) {
    this.priorityStrategy = priorityStrategy;
    return this;
  }

   /**
   * Get priorityStrategy
   * @return priorityStrategy
  **/
  @ApiModelProperty(value = "")
  public KruiseAppsPubUpdatePriorityStrategy getPriorityStrategy() {
    return priorityStrategy;
  }

  public void setPriorityStrategy(KruiseAppsPubUpdatePriorityStrategy priorityStrategy) {
    this.priorityStrategy = priorityStrategy;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy scatterStrategy(List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy) {
    this.scatterStrategy = scatterStrategy;
    return this;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy addScatterStrategyItem(KruiseAppsV1alpha1UpdateScatterTerm scatterStrategyItem) {
    if (this.scatterStrategy == null) {
      this.scatterStrategy = new ArrayList<KruiseAppsV1alpha1UpdateScatterTerm>();
    }
    this.scatterStrategy.add(scatterStrategyItem);
    return this;
  }

   /**
   * ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.
   * @return scatterStrategy
  **/
  @ApiModelProperty(value = "ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.")
  public List<KruiseAppsV1alpha1UpdateScatterTerm> getScatterStrategy() {
    return scatterStrategy;
  }

  public void setScatterStrategy(List<KruiseAppsV1alpha1UpdateScatterTerm> scatterStrategy) {
    this.scatterStrategy = scatterStrategy;
  }

  public KruiseAppsV1alpha1CloneSetUpdateStrategy type(String type) {
    this.type = type;
    return this;
  }

   /**
   * Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.
   * @return type
  **/
  @ApiModelProperty(value = "Type indicates the type of the CloneSetUpdateStrategy. Default is ReCreate.")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (!(o instanceof KruiseAppsV1alpha1CloneSetUpdateStrategy)) {
      return false;
    }
    KruiseAppsV1alpha1CloneSetUpdateStrategy ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy = (KruiseAppsV1alpha1CloneSetUpdateStrategy) o;
    return Objects.equals(this.inPlaceUpdateStrategy, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.inPlaceUpdateStrategy) &&
        Objects.equals(this.maxSurge, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.maxSurge) &&
        Objects.equals(this.maxUnavailable, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.maxUnavailable) &&
        Objects.equals(this.partition, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.partition) &&
        Objects.equals(this.paused, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.paused) &&
        Objects.equals(this.priorityStrategy, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.priorityStrategy) &&
        Objects.equals(this.scatterStrategy, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.scatterStrategy) &&
        Objects.equals(this.type, ioKruiseAppsV1alpha1CloneSetSpecUpdateStrategy.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(inPlaceUpdateStrategy, maxSurge, maxUnavailable, partition, paused, priorityStrategy, scatterStrategy, type);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KruiseAppsV1alpha1CloneSetSpecUpdateStrategy {\n");
    
    sb.append("    inPlaceUpdateStrategy: ").append(toIndentedString(inPlaceUpdateStrategy)).append("\n");
    sb.append("    maxSurge: ").append(toIndentedString(maxSurge)).append("\n");
    sb.append("    maxUnavailable: ").append(toIndentedString(maxUnavailable)).append("\n");
    sb.append("    partition: ").append(toIndentedString(partition)).append("\n");
    sb.append("    paused: ").append(toIndentedString(paused)).append("\n");
    sb.append("    priorityStrategy: ").append(toIndentedString(priorityStrategy)).append("\n");
    sb.append("    scatterStrategy: ").append(toIndentedString(scatterStrategy)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

