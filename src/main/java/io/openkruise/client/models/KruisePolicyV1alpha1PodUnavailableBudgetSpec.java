/*
* Kruise
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.openkruise.client.models;

import com.google.gson.annotations.SerializedName;
import io.kubernetes.client.custom.IntOrString;
import io.kubernetes.client.openapi.models.V1LabelSelector;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.Objects;
import javax.annotation.Generated;

/**
 * PodUnavailableBudgetSpec defines the desired state of PodUnavailableBudget
 */
@ApiModel(description = "PodUnavailableBudgetSpec defines the desired state of PodUnavailableBudget")
@Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2023-07-21T15:55:09.049+08:00")
public class KruisePolicyV1alpha1PodUnavailableBudgetSpec {
  @SerializedName("maxUnavailable")
  private IntOrString maxUnavailable = null;

  @SerializedName("minAvailable")
  private IntOrString minAvailable = null;

  @SerializedName("selector")
  private V1LabelSelector selector = null;

  @SerializedName("targetRef")
  private KruiseAppsV1alpha1TargetReference targetRef = null;

  public KruisePolicyV1alpha1PodUnavailableBudgetSpec maxUnavailable(IntOrString maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
    return this;
  }

   /**
   * Delete pod, evict pod or update pod specification is allowed if at most \&quot;maxUnavailable\&quot; pods selected by \&quot;selector\&quot; or \&quot;targetRef\&quot;  are unavailable after the above operation for pod. MaxUnavailable and MinAvailable are mutually exclusive, MaxUnavailable is priority to take effect
   * @return maxUnavailable
  **/
  @ApiModelProperty(value = "Delete pod, evict pod or update pod specification is allowed if at most \"maxUnavailable\" pods selected by \"selector\" or \"targetRef\"  are unavailable after the above operation for pod. MaxUnavailable and MinAvailable are mutually exclusive, MaxUnavailable is priority to take effect")
  public IntOrString getMaxUnavailable() {
    return maxUnavailable;
  }

  public void setMaxUnavailable(IntOrString maxUnavailable) {
    this.maxUnavailable = maxUnavailable;
  }

  public KruisePolicyV1alpha1PodUnavailableBudgetSpec minAvailable(IntOrString minAvailable) {
    this.minAvailable = minAvailable;
    return this;
  }

   /**
   * Delete pod, evict pod or update pod specification is allowed if at least \&quot;minAvailable\&quot; pods selected by \&quot;selector\&quot; or \&quot;targetRef\&quot; will still be available after the above operation for pod.
   * @return minAvailable
  **/
  @ApiModelProperty(value = "Delete pod, evict pod or update pod specification is allowed if at least \"minAvailable\" pods selected by \"selector\" or \"targetRef\" will still be available after the above operation for pod.")
  public IntOrString getMinAvailable() {
    return minAvailable;
  }

  public void setMinAvailable(IntOrString minAvailable) {
    this.minAvailable = minAvailable;
  }

  public KruisePolicyV1alpha1PodUnavailableBudgetSpec selector(V1LabelSelector selector) {
    this.selector = selector;
    return this;
  }

   /**
   * Get selector
   * @return selector
  **/
  @ApiModelProperty(value = "")
  public V1LabelSelector getSelector() {
    return selector;
  }

  public void setSelector(V1LabelSelector selector) {
    this.selector = selector;
  }

  public KruisePolicyV1alpha1PodUnavailableBudgetSpec targetRef(KruiseAppsV1alpha1TargetReference targetRef) {
    this.targetRef = targetRef;
    return this;
  }

   /**
   * Get targetRef
   * @return targetRef
  **/
  @ApiModelProperty(value = "")
  public KruiseAppsV1alpha1TargetReference getTargetRef() {
    return targetRef;
  }

  public void setTargetRef(KruiseAppsV1alpha1TargetReference targetRef) {
    this.targetRef = targetRef;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (!(o instanceof KruisePolicyV1alpha1PodUnavailableBudgetSpec)) {
      return false;
    }
    KruisePolicyV1alpha1PodUnavailableBudgetSpec ioKruisePolicyV1alpha1PodUnavailableBudgetSpec = (KruisePolicyV1alpha1PodUnavailableBudgetSpec) o;
    return Objects.equals(this.maxUnavailable, ioKruisePolicyV1alpha1PodUnavailableBudgetSpec.maxUnavailable) &&
        Objects.equals(this.minAvailable, ioKruisePolicyV1alpha1PodUnavailableBudgetSpec.minAvailable) &&
        Objects.equals(this.selector, ioKruisePolicyV1alpha1PodUnavailableBudgetSpec.selector) &&
        Objects.equals(this.targetRef, ioKruisePolicyV1alpha1PodUnavailableBudgetSpec.targetRef);
  }

  @Override
  public int hashCode() {
    return Objects.hash(maxUnavailable, minAvailable, selector, targetRef);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KruisePolicyV1alpha1PodUnavailableBudgetSpec {\n");
    
    sb.append("    maxUnavailable: ").append(toIndentedString(maxUnavailable)).append("\n");
    sb.append("    minAvailable: ").append(toIndentedString(minAvailable)).append("\n");
    sb.append("    selector: ").append(toIndentedString(selector)).append("\n");
    sb.append("    targetRef: ").append(toIndentedString(targetRef)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

